Алгоритмы сортировки

1. Сортировка выбором (Selection Sort)

* Идея: На каждом шаге находится минимальный элемент в неотсортированной части массива и меняется местами с первым элементом этой части.
* Сложность: O(n²) во всех случаях (худший, средний, лучший).
* Применение: Прост в понимании и реализации, но неэффективен на больших данных. Подходит для обучения основам алгоритмов.

2. Сортировка обменом (Bubble Sort)

* Идея: Многократно проходим по массиву, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке.
* Сложность: O(n²) в среднем и худшем случаях, O(n) в лучшем (если массив уже отсортирован).
* Применение: Также используется в учебных целях. На практике почти не применяется из-за низкой эффективности.

3. Сортировка вставками (Insertion Sort)

* Идея: Массив делится на отсортированную и неотсортированную части. Каждый новый элемент вставляется в правильную позицию в отсортированной части.
* Сложность: O(n²) в среднем и худшем случаях, O(n) в лучшем.
* Применение: Эффективен для небольших или почти отсортированных массивов. Часто используется как часть более сложных алгоритмов (например, в Timsort).

4. Сортировка слиянием (Merge Sort)

* Идея: Рекурсивно разделяем массив пополам, сортируем каждую половину, затем сливаем их в один отсортированный массив.
* Сложность: O(n log n) во всех случаях.
* Пространственная сложность: O(n) — требуется дополнительная память.
* Применение: Стабилен, подходит для больших данных, особенно когда важна предсказуемая производительность.

5. Сортировка Шелла (Shellsort)

* Идея: Улучшенная версия сортировки вставками. Сначала сортируются элементы, отстоящие друг от друга на некотором шаге (gap), затем шаг уменьшается.
* Сложность: Зависит от выбора последовательности шагов. В среднем — между O(n log n) и O(n²).
* Применение: Эффективен на средних по размеру массивах, прост в реализации.

6. Быстрая сортировка (Quick Sort)

* Идея: Выбирается опорный элемент, массив разбивается на две части: элементы меньше опорного и больше. Процесс повторяется рекурсивно.
* Сложность: O(n log n) в среднем, O(n²) в худшем случае (редко, если опорный элемент выбирается неудачно).
* Применение: Один из самых популярных алгоритмов на практике благодаря высокой скорости на случайных данных.

7. Пирамидальная сортировка (Heap Sort)

* Идея: Строится двоичная куча (max-heap), затем максимальный элемент извлекается и помещается в конец массива. Процесс повторяется.
* Сложность: O(n log n) во всех случаях.
* Применение: Гарантированная сложность O(n log n), не требует дополнительной памяти. Используется в системах с ограниченными ресурсами.

---

Алгоритмы поиска

1. Последовательный поиск (Linear Search)

* Идея: Поочерёдное сравнение каждого элемента с искомым значением.
* Сложность: O(n).
* Применение: Подходит для небольших или неотсортированных массивов.

2. Бинарный поиск (Binary Search)

* Идея: Поиск в отсортированном массиве путём деления его пополам на каждой итерации.
* Сложность: O(log n).
* Применение: Эффективен для больших отсортированных массивов.

3. Интерполирующий поиск (Interpolation Search)

* Идея: Улучшенный бинарный поиск, который предсказывает позицию искомого элемента на основе значений.
* Сложность: O(log log n) при равномерном распределении, O(n) в худшем случае.
* Применение: Эффективен на больших массивах с равномерно распределёнными данными.

4. Поиск Фибоначчи (Fibonacci Search)

* Идея: Использует числа Фибоначчи для определения позиций сравнения. Аналогичен бинарному поиску, но делит массив в золотом сечении.
* Сложность: O(log n).
* Применение: Альтернатива бинарному поиску, может быть эффективнее на некоторых архитектурах.
